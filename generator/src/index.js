/**
 * ============================================
 * AHteam Generator - Main Entry Point (Updated)
 * ============================================
 * 
 * Generates:
 * - Website from templates/website
 * - Admin from templates/admin
 * ============================================
 */

import fs from 'fs-extra';
import path from 'path';
import { fileURLToPath } from 'url';
import { validate, getValueByPath } from './validator.js';
import { processFile, shouldProcessFile } from './binder.js';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// SEO Templates
const DEFAULT_META = {
    title: 'AHteam Store',
    description: 'High-performance commerce experience by AHteam',
    og_image: './assets/images/logo.png',
    og_type: 'website'
};

// Paths
const ROOT_DIR = path.resolve(__dirname, '../..');
const CONFIG_PATH = path.join(ROOT_DIR, 'project.config.json');
const TEMPLATES_DIR = path.join(ROOT_DIR, 'templates');
const OUTPUT_DIR = path.join(ROOT_DIR, 'generated');
const TOKENS_DIR = path.join(ROOT_DIR, 'tokens');

let globalTokens = {};

/**
 * Main generator function
 */
async function generate() {
    console.log('üè≠ AHteam Generator v2.0.0 (Inheritance Mode)\n');
    console.log('===============================================\n');

    // 1. Load Tokens
    await loadTokens();

    // 2. Load config
    const config = JSON.parse(await fs.readFile(CONFIG_PATH, 'utf-8'));

    // Inject tokens into config for binders to use
    config._tokens = globalTokens;

    // Generate Website if enabled
    if (config.features?.website?.enabled) {
        console.log('üìÑ Generating Website...\n');
        await generateWebsite(config);
    }

    // Generate Admin
    console.log('\nüìä Generating Admin Panel...\n');
    await generateAdmin(config);

    // Generate Android
    console.log('\nüì± Generating Android App...\n');
    await generateAndroid(config);

    console.log('\n================================');
    console.log('‚úÖ All Generation Complete!\n');
    console.log(`üìÅ Website: ${path.join(OUTPUT_DIR, 'website')}`);
    console.log(`üìÅ Admin: ${path.join(OUTPUT_DIR, 'admin')}`);
    console.log(`üìÅ Android: ${path.join(OUTPUT_DIR, 'android')}`);
    console.log('');
}

/**
 * Generate Admin Panel
 */
async function generateAdmin(config) {
    const templateIdentifier = config.templates?.admin || 'admin/admin-basic-001';
    const template = await resolveTemplate(templateIdentifier);
    const templatePath = template._basePath;
    const adminOutput = path.join(OUTPUT_DIR, 'admin');

    console.log(`   üé® Using template: ${template.id || templateIdentifier}`);

    // Prepare output
    await fs.ensureDir(adminOutput);
    await fs.emptyDir(adminOutput);

    // Copy and process pages
    const pagesDir = path.join(templatePath, 'pages');
    if (await fs.pathExists(pagesDir)) {
        const pages = await fs.readdir(pagesDir);
        for (const page of pages) {
            const sourcePath = path.join(pagesDir, page);
            const destPath = path.join(adminOutput, page);
            let content = await fs.readFile(sourcePath, 'utf-8');
            content = processFile(content, config, page);
            await fs.writeFile(destPath, content);
            console.log(`   ‚úÖ ${page}`);
        }
    }

    // Copy and process assets
    const assetsDir = path.join(templatePath, 'assets');
    if (await fs.pathExists(assetsDir)) {
        await copyAndProcessDir(assetsDir, path.join(adminOutput, 'assets'), config);
        console.log('   ‚úÖ assets/');
    }

    // Generate admin docs
    await generateAdminDocs(config, adminOutput);
}

/**
 * Copy directory and process text files
 */
async function copyAndProcessDir(sourceDir, destDir, config) {
    await fs.ensureDir(destDir);
    const items = await fs.readdir(sourceDir, { withFileTypes: true });

    for (const item of items) {
        const sourcePath = path.join(sourceDir, item.name);
        const destPath = path.join(destDir, item.name);

        if (item.isDirectory()) {
            await copyAndProcessDir(sourcePath, destPath, config);
        } else {
            if (shouldProcessFile(item.name)) {
                let content = await fs.readFile(sourcePath, 'utf-8');
                content = processFile(content, config, item.name);
                await fs.writeFile(destPath, content);
            } else {
                await fs.copy(sourcePath, destPath);
            }
        }
    }
}

/**
 * Generate Website docs
 */
async function generateWebsiteDocs(config, outputPath) {
    const readme = `# ${config.project.name} - Website

## Quick Start
\`\`\`bash
# Serve locally
npx serve .
\`\`\`

## Files
- index.html - Home page
- products.html - Products
- cart.html - Shopping cart
- about.html - About us
- contact.html - Contact

## Generated by AHteam Factory
`;
    await fs.writeFile(path.join(outputPath, 'README.md'), readme);
    console.log('   ‚úÖ README.md');
}

/**
 * Generate Admin docs
 */
async function generateAdminDocs(config, outputPath) {
    const readme = `# ${config.project.name} - Admin Panel

## Quick Start
\`\`\`bash
# Serve locally
npx serve -p 3001 .
\`\`\`

## Login
- Username: admin
- Password: admin123

## Pages
- login.html - Login page
- dashboard.html - Dashboard
- content.html - Edit content
- settings.html - Store settings

## Features
- ‚úÖ Local Authentication
- ‚úÖ Config Editor
- ‚úÖ No external dependencies

## Generated by AHteam Factory
`;
    await fs.writeFile(path.join(outputPath, 'README.md'), readme);
    console.log('   ‚úÖ README.md');
}

/**
 * Generate Android App
 */
async function generateAndroid(config) {
    const templateIdentifier = config.templates?.android || 'android/android-webview-001';
    const template = await resolveTemplate(templateIdentifier);
    const templatePath = template._basePath;
    const androidOutput = path.join(OUTPUT_DIR, 'android');

    console.log(`   üé® Using template: ${template.id || templateIdentifier}`);

    // Prepare output
    await fs.ensureDir(androidOutput);
    await fs.emptyDir(androidOutput);

    // Copy entire template structure
    await copyAndProcessDir(templatePath, androidOutput, config);
    console.log('   ‚úÖ Android project structure');

    // Generate README
    await generateAndroidDocs(config, androidOutput);
}

/**
 * Generate Android docs
 */
async function generateAndroidDocs(config, outputPath) {
    const readme = `# ${config.project.name} - Android App

## ÿßŸÑŸÖÿ™ÿ∑ŸÑÿ®ÿßÿ™
- Android Studio Arctic Fox ÿ£Ÿà ÿ£ÿ≠ÿØÿ´
- JDK 11 ÿ£Ÿà ÿ£ÿ≠ÿØÿ´

## ÿßŸÑÿ®ŸÜÿßÿ°
1. ÿßŸÅÿ™ÿ≠ ÿßŸÑŸÖÿ¥ÿ±Ÿàÿπ ŸÅŸä Android Studio
2. ÿßŸÜÿ™ÿ∏ÿ± sync ÿßŸÑŸÄ Gradle
3. Build ‚Üí Build APK(s)

## ÿ™ÿ≥ÿ¨ŸäŸÑ ÿßŸÑÿØÿÆŸàŸÑ
- Ÿáÿ∞ÿß ÿ™ÿ∑ÿ®ŸäŸÇ WebView
- ŸÑÿß Ÿäÿ™ÿ∑ŸÑÿ® ÿ™ÿ≥ÿ¨ŸäŸÑ ÿØÿÆŸàŸÑ ÿÆÿßÿµ

## Generated by AHteam Factory
`;
    await fs.writeFile(path.join(outputPath, 'README.md'), readme);
    console.log('   ‚úÖ README.md');
}

/**
 * Load Design Tokens from global tokens directory
 */
/**
 * Load all tokens recursively from the tokens directory
 * Resulting keys are namespaced: "namespace.filename"
 */
async function loadTokens() {
    if (!(await fs.pathExists(TOKENS_DIR))) return;

    async function scanDir(dir, prefix = '') {
        const entries = await fs.readdir(dir, { withFileTypes: true });
        for (const entry of entries) {
            const fullPath = path.join(dir, entry.name);
            if (entry.isDirectory()) {
                await scanDir(fullPath, `${prefix}${entry.name}.`);
            } else if (entry.name.endsWith('.json')) {
                const key = `${prefix}${entry.name.replace('.json', '')}`;
                globalTokens[key] = JSON.parse(await fs.readFile(fullPath, 'utf-8'));
            }
        }
    }

    await scanDir(TOKENS_DIR);
    console.log('üíé Tokens Loaded:', Object.keys(globalTokens).join(', '));
}

/**
 * Resolve Token (e.g. "colors.primary" -> "#3b82f6")
 */
function resolveToken(tokenPath) {
    if (!tokenPath || typeof tokenPath !== 'string') return tokenPath;
    const parts = tokenPath.split('.');
    if (parts.length !== 2) return tokenPath;

    const [group, key] = parts;
    return globalTokens[group]?.[key] || tokenPath;
}

/**
 * Resolve a variant with its Layout and Tokens
 * Enforces Immutable Hierarchy: Base -> Layout -> Variant -> Tokens
 */
/**
 * Recursive layout search
 */
async function findLayout(layoutName) {
    async function scan(dir) {
        const entries = await fs.readdir(dir, { withFileTypes: true });
        for (const entry of entries) {
            const fullPath = path.join(dir, entry.name);
            if (entry.isDirectory()) {
                const found = await scan(fullPath);
                if (found) return found;
            } else if (entry.name === `${layoutName}.json`) {
                return JSON.parse(await fs.readFile(fullPath, 'utf-8'));
            }
        }
        return null;
    }
    return await scan(path.join(TEMPLATES_DIR, 'layouts'));
}

/**
 * Resolve a variant with its Layout and Tokens
 */
async function resolveVariant(variantName) {
    const variantDir = path.join(TEMPLATES_DIR, 'variants', variantName);
    const contractPath = path.join(variantDir, 'contract.json');

    if (!(await fs.pathExists(contractPath))) {
        throw new Error(`‚ùå IMMUTABLE ERROR: Variant "${variantName}" is missing a mandatory contract.json at ${contractPath}`);
    }

    const variant = JSON.parse(await fs.readFile(contractPath, 'utf-8'));

    // ‚õî Rule: No Variant Inheritance
    if (variant.extends || variant.parent) {
        throw new Error(`‚ùå IMMUTABLE ERROR: Variant "${variantName}" attempts illegal inheritance. Variants must be standalone contracts.`);
    }

    // Resolve Layout (Recursive search to support Vertical subdirectories)
    const layout = await findLayout(variant.layout);

    if (!layout) {
        throw new Error(`‚ùå FAIL-FAST: Layout "${variant.layout}" requested by variant "${variantName}" was not found in any vertical subdirectory.`);
    }

    // ‚õî Rule: Layout Vertical Guard
    if (variant.vertical && layout.vertical && variant.vertical !== layout.vertical) {
        throw new Error(`‚ùå VERTICAL MISMATCH: Variant "${variantName}" (Vertical: ${variant.vertical}) attempted to use Layout "${variant.layout}" (Vertical: ${layout.vertical}).`);
    }

    // ‚õî Rule: No Layout Inheritance
    if (layout.extends || layout.parent) {
        throw new Error(`‚ùå IMMUTABLE ERROR: Layout "${variant.layout}" attempts illegal inheritance.`);
    }

    // üß© Step 2: Assemble Token Profile
    const profile = variant.tokenProfile || 'global';
    const profileTokens = {};

    // Merge Strategy: Start with global, then override with profile
    const tokenGroups = ['colors', 'fonts', 'spacing', 'radius', 'shadows', 'commerce'];

    for (const group of tokenGroups) {
        const globalGroup = globalTokens[`global.${group}`] || {};
        const activeGroup = globalTokens[`${profile}.${group}`] || {};
        profileTokens[group] = { ...globalGroup, ...activeGroup };
    }

    // Attach to variant for the binder to find it
    variant._tokens = profileTokens;

    return { variant, layout };
}

/**
 * Compose a page from Components and Layout
 */
async function composePage(layout, config) {
    const skeletonPath = path.join(TEMPLATES_DIR, 'base', 'skeleton.html');
    let skeleton = await fs.readFile(skeletonPath, 'utf-8');

    let sectionsHtml = '';
    for (const sectionId of layout.sections) {
        const componentPath = path.join(TEMPLATES_DIR, 'base', 'components', `${sectionId}.html`);
        if (await fs.pathExists(componentPath)) {
            const compContent = await fs.readFile(componentPath, 'utf-8');
            sectionsHtml += `\n<!-- Section: ${sectionId} -->\n${compContent}\n`;
        } else {
            throw new Error(`‚ùå FAIL-FAST: Component "${sectionId}" required by Layout was not found at ${componentPath}`);
        }
    }

    return skeleton.replace('{{COMPOSER_SECTIONS}}', sectionsHtml);
}

/**
 * üîí Step 4.5 - Variant Contract Validation
 * Validates that the variant correctly implements component requirements.
 */
async function validateVariantContract(variant, layout, config) {
    console.log('   üîí Validating Variant Contract (Step 3 Enforcement)...');

    const profile = variant.tokenProfile || 'global';
    const profileParts = profile.split('.');
    const familyId = profileParts[0];

    // ‚õî Hardened Rule: Design Family Contract Check
    const familyContractPath = path.join(TOKENS_DIR, familyId, 'family.json');
    if (await fs.pathExists(familyContractPath)) {
        const family = JSON.parse(await fs.readFile(familyContractPath, 'utf-8'));

        // Check if layout sections are allowed by family
        for (const sectionId of layout.sections) {
            if (family.allowedComponents && !family.allowedComponents.includes(sectionId)) {
                // Warning only for now to allow flexibility, but could be error
                console.warn(`    ‚ö†Ô∏è  FAMILY GUARD: Component "${sectionId}" is not officially supported by Design Family "${familyId}".`);
            }
        }
    }

    // ‚õî Hardened Rule: Required Components (Layout Level)
    if (layout.requiredComponents) {
        for (const reqComp of layout.requiredComponents) {
            if (!layout.sections.includes(reqComp)) {
                throw new Error(`‚ùå LAYOUT VIOLATION: Layout "${layout.id}" requires component "${reqComp}" which is missing from its "sections" list.`);
            }
        }
    }

    // ‚õî Hardened Rule: Business Goal declaration
    if (!variant.goal) {
        console.warn(`    ‚ö†Ô∏è  CONVERSION WARNING: Variant "${variant.id}" is missing a mandatory "goal" declaration (sell, book, showcase, collect-leads).`);
    }

    // 1. Check Component Variants match Base Manifests
    const componentVariants = variant.componentVariants || {};
    for (const sectionId of layout.sections) {
        const manifestPath = path.join(TEMPLATES_DIR, 'base', 'components', `${sectionId}.component.json`);

        if (!(await fs.pathExists(manifestPath))) {
            throw new Error(`‚ùå FAIL-FAST: Component manifest missing for "${sectionId}". Every base component must have a manifest.`);
        }

        const manifest = JSON.parse(await fs.readFile(manifestPath, 'utf-8'));

        // ‚õî Rule 3.1: Variant Support
        const selectedVariant = componentVariants[sectionId];
        if (selectedVariant && !manifest.supportedVariants.includes(selectedVariant)) {
            throw new Error(`‚ùå INVALID VARIANT: Component "${sectionId}" does not support variant "${selectedVariant}". Supported: ${manifest.supportedVariants.join(', ')}`);
        }

        // ‚õî Rule 3.2: Required Tokens (Component Contract)
        if (manifest.requiredTokens) {
            for (const tRef of manifest.requiredTokens) {
                const parts = tRef.split('.');
                if (parts.length === 2) {
                    const [group, key] = parts;
                    if (!variant._tokens?.[group] || !variant._tokens[group][key]) {
                        throw new Error(`‚ùå CONTRACT VIOLATION: Component "${sectionId}" requires token "${tRef}" which is not provided by profile "${variant.tokenProfile}".`);
                    }
                }
            }
        }

        // ‚õî Rule 3.3: Required Props (Component Contract)
        if (manifest.requiredProps) {
            for (const propPath of manifest.requiredProps) {
                const value = getValueByPath(config, propPath);
                if (value === undefined || value === null) {
                    throw new Error(`‚ùå CONTRACT VIOLATION: Component "${sectionId}" requires prop "${propPath}" which is missing from project config.`);
                }
            }
        }
    }

    // 2. Token Integrity Check (Single Source of Truth)
    if (variant.tokens) {
        for (const [key, tokenValue] of Object.entries(variant.tokens)) {
            if (typeof tokenValue === 'string' && tokenValue.includes('.')) {
                const [group, tKey] = tokenValue.split('.');
                if (!globalTokens[group] || !globalTokens[group][tKey]) {
                    throw new Error(`‚ùå TOKEN ERROR: Reference "${tokenValue}" for "${key}" not found in global tokens.`);
                }
            }
        }
    }

    console.log('   ‚úÖ Contract Validated');
}

/**
 * Generate a Search Index for the store
 */
async function generateSearchIndex(products, outputPath) {
    console.log('   üîç Generating Smart Search Index (Facet-Ready)...');

    // 1. Build Index with Facets
    const facets = {
        categories: [...new Set(products.map(p => p.category))],
        priceRanges: [
            { label: 'Under $50', min: 0, max: 50 },
            { label: '$50 - $100', min: 50, max: 100 },
            { label: 'Over $100', min: 100, max: 1000000 }
        ],
        attributes: {} // Collect unique attribute values for filtering
    };

    const indexRows = products.map(p => {
        // Collect dynamic facets from attributes
        if (p.attributes) {
            Object.entries(p.attributes).forEach(([key, val]) => {
                if (!facets.attributes[key]) facets.attributes[key] = new Set();
                if (Array.isArray(val)) val.forEach(v => facets.attributes[key].add(v));
                else facets.attributes[key].add(val);
            });
        }

        return {
            id: p.id,
            sku: p.sku,
            name: p.name,
            slug: p.slug,
            category: p.category,
            basePrice: p.basePrice,
            image: p.images?.[0] || '',
            tags: p.tags || [],
            attributes: p.attributes || {}
        };
    });

    // Convert Sets to Arrays for JSON
    Object.keys(facets.attributes).forEach(k => {
        facets.attributes[k] = [...facets.attributes[k]];
    });

    const finalIndex = {
        generatedAt: new Date().toISOString(),
        products: indexRows,
        facets: facets
    };

    const dataDir = path.join(outputPath, 'data');
    await fs.ensureDir(dataDir);
    await fs.writeFile(path.join(dataDir, 'search-index.json'), JSON.stringify(finalIndex, null, 2));
    console.log('   ‚úÖ Smart Index Generated');
}

/**
 * Generate Dynamic Product Pages
 */
async function generateDynamicPages(products, layoutName, config, outputPath) {
    console.log(`   üìÑ Generating Dynamic Pages for ${products.length} products...`);

    // Resolve Product Layout
    const layoutPath = path.join(TEMPLATES_DIR, 'layouts', `${layoutName}.json`);
    if (!(await fs.pathExists(layoutPath))) {
        console.log(`   ‚ö†Ô∏è Layout not found: ${layoutName}, skipping dynamic pages.`);
        return;
    }
    const layout = JSON.parse(await fs.readFile(layoutPath, 'utf-8'));

    for (const product of products) {
        // Aliases for legacy template compatibility
        product.price = product.basePrice;
        product.image = product.images?.[0] || '';

        // Create a local config copy with the current product context
        const pageConfig = {
            ...config,
            _current_product: product,
            _current_product_json: JSON.stringify(product),
            _current_product_attributes: Object.entries(product.attributes || {})
                .map(([k, v]) => `<div class="attribute-item"><strong>${k}:</strong> ${Array.isArray(v) ? v.join(', ') : v}</div>`)
                .join('')
        };

        const composedHtml = await composePage(layout, pageConfig);
        const finalHtml = processFile(composedHtml, pageConfig, `product-${product.id}.html`);

        await fs.writeFile(path.join(outputPath, `product-${product.id}.html`), finalHtml);
        console.log(`   ‚úÖ Page: product-${product.id}.html`);
    }
}

/**
 * Generate Custom Pages defined in the Variant
 */
async function generateCustomPages(pages, config, outputPath) {
    if (!pages) return;
    console.log(`   üìÑ Generating ${Object.keys(pages).length} custom pages...`);

    for (const [pageSlug, pageDef] of Object.entries(pages)) {
        // Resolve Layout
        const layoutPath = path.join(TEMPLATES_DIR, 'layouts', `${pageDef.layout}.json`);
        if (!(await fs.pathExists(layoutPath))) {
            console.log(`   ‚ö†Ô∏è Layout not found for custom page: ${pageDef.layout}`);
            continue;
        }

        const layout = JSON.parse(await fs.readFile(layoutPath, 'utf-8'));

        // If the page definition overrides sections
        if (pageDef.sections) {
            layout.sections = pageDef.sections;
        }

        const pageConfig = { ...config, _page_slug: pageSlug };
        const composedHtml = await composePage(layout, pageConfig);
        const finalHtml = processFile(composedHtml, pageConfig, `${pageSlug}.html`);
        await fs.writeFile(path.join(outputPath, `${pageSlug}.html`), finalHtml);
        console.log(`   ‚úÖ Page: ${pageSlug}.html`);
    }
}

/**
 * Generate Category Pages for all unique categories
 */
async function generateCategoryPages(products, layoutName, config, outputPath) {
    const categories = [...new Set(products.map(p => p.category))];
    console.log(`   üìÇ Generating Category Pages for ${categories.length} categories...`);

    for (const cat of categories) {
        const catProducts = products.filter(p => p.category === cat);
        const pageConfig = {
            ...config,
            _current_category: cat,
            _composed_data: { products: catProducts },
            project: {
                ...config.project,
                title: `${cat.charAt(0).toUpperCase() + cat.slice(1)} - ${config.project?.name || 'Store'}`
            }
        };

        // Resolve Layout (Faceted Search)
        const layout = await findLayout(layoutName);
        if (!layout) {
            console.warn(`    ‚ö†Ô∏è Layout not found: ${layoutName}, skipping category pages.`);
            return;
        }

        const composedHtml = await composePage(layout, pageConfig);
        const finalHtml = processFile(composedHtml, pageConfig, `category-${cat}.html`);

        await fs.writeFile(path.join(outputPath, `category-${cat}.html`), finalHtml);
        console.log(`   ‚úÖ Category Page: category-${cat}.html`);
    }
}

/**
 * Inject SEO Tags into HTML head
 */
function injectSEOTags(html, meta) {
    const tags = `
    <!-- SEO Hardened -->
    <title>${meta.title || DEFAULT_META.title}</title>
    <meta name="description" content="${meta.description || DEFAULT_META.description}">
    <meta property="og:title" content="${meta.title || DEFAULT_META.title}">
    <meta property="og:description" content="${meta.description || DEFAULT_META.description}">
    <meta property="og:image" content="${meta.og_image || DEFAULT_META.og_image}">
    <meta property="og:type" content="${meta.og_type || DEFAULT_META.og_type}">
    <meta name="twitter:card" content="summary_large_image">
    <link rel="canonical" href="${meta.canonical || ''}">
    `;
    return html.replace('</head>', `${tags}\n</head>`);
}

/**
 * Update generateWebsite to use Composer Pipeline with Global Commerce features
 */
async function generateWebsite(config) {
    const variantName = config.features?.website?.template_variant || 'modern-01';
    console.log(`   üéπ Composing Website via Variant: ${variantName}`);

    const { variant, layout } = await resolveVariant(variantName);

    const websiteOutput = path.join(OUTPUT_DIR, 'website');
    await fs.ensureDir(websiteOutput);
    await fs.emptyDir(websiteOutput);

    // 1. Data Selection (Universal Commerce Scale)
    let products = [];
    const vertical = variant.vertical;
    const commercePath = path.join(TOKENS_DIR, 'commerce', vertical, 'products.json');

    if (await fs.pathExists(commercePath)) {
        console.log(`   üì¶ Loading Universal Commerce Data: ${vertical}`);
        products = JSON.parse(await fs.readFile(commercePath, 'utf-8'));
    } else {
        console.warn(`    ‚ö†Ô∏è  DATA WARNING: No commerce data found for vertical "${vertical}" at ${commercePath}. Using empty dataset.`);
    }

    // Inject products into config for composition
    config._composed_data = { products };

    // 2. Compose the Landing Page (index.html)
    const composedHtml = await composePage(layout, config);
    const finalHtml = processFile(composedHtml, config, 'index.html');
    await fs.writeFile(path.join(websiteOutput, 'index.html'), finalHtml);
    console.log('   ‚úÖ Composer: index.html generated');

    // 3. Dynamic Pages (Product Details)
    const productLayout = variant.productLayout || 'ecommerce-product';
    await generateDynamicPages(products, productLayout, config, websiteOutput);

    // 4. Category Pages
    const categoryLayout = variant.categoryLayout || 'ecommerce-category';
    await generateCategoryPages(products, categoryLayout, config, websiteOutput);

    // 5. Custom Pages (Static)
    await generateCustomPages(variant.pages, config, websiteOutput);

    // 6. Search Index Generation
    if (variant.features?.search) {
        await generateSearchIndex(products, websiteOutput);
    }

    // 6. Data Sync
    const dataDir = path.join(websiteOutput, 'data');
    await fs.ensureDir(dataDir);
    await fs.writeFile(path.join(dataDir, 'products.json'), JSON.stringify(products, null, 2));

    // üîí Step 4.5 - Validation Gate (Enforced Hierarchy)
    // Now done after all data (static + dynamic) is ready
    await validateVariantContract(variant, layout, config);

    // 7. Copy shared assets
    const legacyAssets = path.join(TEMPLATES_DIR, 'website', 'web-ecommerce-001', 'assets');
    if (await fs.pathExists(legacyAssets)) {
        await copyAndProcessDir(legacyAssets, path.join(websiteOutput, 'assets'), config);
    }
}

/**
 * Resolve a template with Inheritance
 */
async function resolveTemplate(templateIdentifier) {
    // If it's a file path to a variant JSON
    if (templateIdentifier.endsWith('.json')) {
        const variantPath = path.join(TEMPLATES_DIR, templateIdentifier);
        const variant = JSON.parse(await fs.readFile(variantPath, 'utf-8'));

        if (variant.inheritsFrom) {
            const basePath = path.join(TEMPLATES_DIR, variant.inheritsFrom);
            const baseManifestPath = path.join(basePath, 'manifest.json');
            const base = JSON.parse(await fs.readFile(baseManifestPath, 'utf-8'));

            // Merge base and variant
            return {
                ...base,
                ...variant,
                tokens: { ...base.tokens, ...variant.tokens },
                overrides: { ...base.overrides, ...variant.overrides },
                _basePath: basePath
            };
        }
        return variant;
    }

    // Default legacy behavior
    return { _basePath: path.join(TEMPLATES_DIR, templateIdentifier) };
}

// Run generator
generate().catch(err => {
    console.error('‚ùå Generation failed:', err.message);
    process.exit(1);
});
